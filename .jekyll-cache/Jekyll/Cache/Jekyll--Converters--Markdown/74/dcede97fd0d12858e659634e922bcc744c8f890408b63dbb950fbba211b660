I"îO<p><img src="/assets/img/1*eZcgzUUKk-PnETNqIXMfcw.png" alt="" />
Functional reactive programming is laden with unfamiliar terminology to the newcomer: pure functions, immutability, monads, etc. But beneath these concepts is a deeper principle ‚Äî one debated long before Charles Babbage and the first computers. <!--more-->I argue the difference between object-oriented programming (OOP) and functional reactive programming (FRP) is as much about interpretations of reality as it is about structures of programs.</p>

<p>Here‚Äôs a thought experiment we‚Äôve all likely heard:</p>

<blockquote>
  <p>If a tree falls in the middle of a forest, and no one is there to hear it, does it make a sound?</p>
</blockquote>

<p>There are many of ways to attack this question as ill-posed. Ignoring them for the moment, this question is poking at a fundamental aspect of reality: causality. Is existence dependent on, or independent of, observation? Let‚Äôs translate this thought experiment into code. Here‚Äôs a <code class="language-plaintext highlighter-rouge">tree</code>.</p>

<div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">class</span> <span class="nx">Tree</span> <span class="p">{</span>   
  <span class="kd">constructor</span><span class="p">(){</span>   
    <span class="k">this</span><span class="p">.</span><span class="nx">_fell</span> <span class="o">=</span> <span class="kc">false</span><span class="p">;</span>   
  <span class="p">}</span>   

  <span class="kd">set</span> <span class="nx">fell</span><span class="p">(</span><span class="nx">state</span><span class="p">){</span>   
    <span class="k">this</span><span class="p">.</span><span class="nx">_fell</span> <span class="o">=</span> <span class="nx">state</span><span class="p">;</span>   
  <span class="p">}</span>   

  <span class="kd">get</span> <span class="nx">fell</span><span class="p">(){</span>   
    <span class="k">return</span> <span class="k">this</span><span class="p">.</span><span class="nx">_fell</span><span class="p">;</span>   
  <span class="p">}</span>  
<span class="p">}</span> 
<span class="kd">var</span> <span class="nx">tree</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">Tree</span><span class="p">();</span>  
<span class="nx">tree</span><span class="p">.</span><span class="nx">fell</span> <span class="o">=</span> <span class="kc">true</span><span class="p">;</span>
</code></pre></div></div>

<p>To make the <code class="language-plaintext highlighter-rouge">tree</code> fall we set its fallen state to <code class="language-plaintext highlighter-rouge">true</code>. This is textbook object-oriented programming. Its patterns are getters, setters, and state. Simple enough, but in the context of our thought experiment there is a lurking interpretation: if one questions whether the tree fell, even if they didn‚Äôt observe it, the answer is a resounding ‚Äú<em>Yes!</em>‚Äù One only needs to check that <code class="language-plaintext highlighter-rouge">tree.fell</code> <em>is <code class="language-plaintext highlighter-rouge">true</code>. Those that answer *yes</em> to our philosophical question do so because they can return to the forest, see the fallen tree, and deduce it fell in the past. Here is the codified equivalent. Looks like we‚Äôve solved that centuries-old riddle.</p>

<p>Not so fast! Let‚Äôs look at a different approach. Here‚Äôs another <code class="language-plaintext highlighter-rouge">tree</code>:</p>

<div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">class</span> <span class="nx">Tree</span> <span class="kd">extends</span> <span class="nx">EventEmitter</span> <span class="p">{}</span>  
  
<span class="kd">var</span> <span class="nx">tree</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">Tree</span><span class="p">();</span>  
<span class="nx">tree</span><span class="p">.</span><span class="nx">emit</span><span class="p">(</span><span class="dl">'</span><span class="s1">fall</span><span class="dl">'</span><span class="p">);</span>
</code></pre></div></div>

<p>This is the <em>reactive</em> <code class="language-plaintext highlighter-rouge">tree</code>. Its patterns are events and transforms. In its purest form our tree maintains no state. We make it fall by broadcasting a <code class="language-plaintext highlighter-rouge">fall</code> event. Alas, the message falls on deaf ears! No state has changed, no evidence is left. There is no way to deduce the past by querying reality. Did the tree fall? <em>shrug</em></p>

<h3 id="descartes-and-berkeley">Descartes and Berkeley</h3>

<p>The object-oriented and reactive approaches give two different answers to our thought experiment because they embody two contradictory philosophies of epistemology: Rationalism, popularized by Descartes in the late 1600s, and Empiricism popularized by Berkeley in the early 1700s.</p>

<p><img src="/assets/img/1*6YaJYhP7N-Ue4p3CWr1cYw.png" alt="" /></p>

<p>Descartes takes as a short break from writing a Java interfaceDescartes, in a streak of fanatical skepticism, found he could only be sure of one thing: his own existence. He came to this conclusion because he couldn‚Äôt doubt the existence of his thoughts and concluded there must be some entity doing the thinking, thus coining the phrase, <em>cogito ergo sum</em>: I think therefore I am. In other words: by acknowledging that there is some internal state that is changing, there must be some agent for whom the state belongs. To Descartes, changes of state is proof of existence ‚Äî just like our first <code class="language-plaintext highlighter-rouge">tree</code>.</p>

<p><img src="/assets/img/1*e_9xwJkCExj4-jBsLgGJag.png" alt="" /></p>

<p>Berkeley seen pondering Haskell type definitionsSoon after Descartes comes George Berkeley. Berkeley denounced the realist‚Äôs view. To Berkeley, it made no sense for material objects, like trees, to have existence. Existence only comes to us through thoughts (mental as opposed to physical experience), and thoughts must assimilate in the mind to exist. Material objects are deceptions; their essence is not their physicality but their ability to transform the immaterial. If a thought is not assimilated in the mind, it has no existence. Thus he popularized the Latin phrase <em>esse percepi</em>: to be is to be perceived.</p>

<p>Let‚Äôs translate Berkeley‚Äôs reality into code. For our second <code class="language-plaintext highlighter-rouge">tree</code> to make a sound a mind must interpret it. We will create a chain of causality, starting from the tree falling, to the air vibrating, to the ear creating an electrical stimulus, to the brain interpreting it as sound.</p>

<p><img src="/assets/img/1*3JOSU7inWkTzeI-hR-FMLA.png" alt="" /></p>

<p>When the tree falls, the air vibrates.</p>

<div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">class</span> <span class="nx">Air</span> <span class="kd">extends</span> <span class="nx">EventEmitter</span> <span class="p">{</span>  
  <span class="kd">constructor</span> <span class="p">(){</span>  
    <span class="k">super</span><span class="p">();</span>   
    <span class="kd">function</span> <span class="nx">mapFall</span> <span class="p">(</span><span class="nx">fall</span><span class="p">){...}</span>  
 
    <span class="k">this</span><span class="p">.</span><span class="nx">on</span><span class="p">(</span><span class="dl">'</span><span class="s1">fall</span><span class="dl">'</span><span class="p">,</span> <span class="p">(</span><span class="nx">fall</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="p">{</span>  
      <span class="kd">var</span> <span class="nx">vibration</span> <span class="o">=</span> <span class="nx">mapFall</span><span class="p">(</span><span class="nx">fall</span><span class="p">);</span>  
      <span class="k">this</span><span class="p">.</span><span class="nx">emit</span><span class="p">(</span><span class="dl">'</span><span class="s1">vibrate</span><span class="dl">'</span><span class="p">,</span> <span class="nx">vibration</span><span class="p">);</span>  
    <span class="p">};</span>  
  <span class="p">}</span>  
<span class="p">}</span>
</code></pre></div></div>

<p>When the air vibrates, the ear converts it to an electrical stimulus.</p>

<div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">class</span> <span class="nx">Ear</span> <span class="kd">extends</span> <span class="nx">EventEmitter</span> <span class="p">{</span>  
  <span class="kd">constructor</span> <span class="p">(){</span>   
    <span class="k">super</span><span class="p">();</span>   
    <span class="kd">function</span> <span class="nx">mapFrequency</span> <span class="p">(</span><span class="nx">frequency</span><span class="p">){...}</span>  
  
    <span class="k">this</span><span class="p">.</span><span class="nx">on</span><span class="p">(</span><span class="dl">'</span><span class="s1">vibrate</span><span class="dl">'</span><span class="p">,</span> <span class="p">(</span><span class="nx">frequency</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="p">{</span>  
      <span class="kd">var</span> <span class="nx">stimulus</span> <span class="o">=</span> <span class="nx">mapFrequency</span><span class="p">(</span><span class="nx">frequency</span><span class="p">);</span>  
      <span class="k">this</span><span class="p">.</span><span class="nx">emit</span><span class="p">(</span><span class="dl">'</span><span class="s1">stimulus</span><span class="dl">'</span><span class="p">,</span> <span class="nx">stimulus</span><span class="p">);</span>  
    <span class="p">};</span>  
  <span class="p">}</span>  
<span class="p">}</span>
</code></pre></div></div>

<p>When ear creates a stimulus, the brain interprets it as sound.</p>

<div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">class</span> <span class="nx">Brain</span> <span class="kd">extends</span> <span class="nx">EventEmitter</span> <span class="p">{</span>  
  <span class="kd">constructor</span> <span class="p">(){</span>  
    <span class="k">super</span><span class="p">();</span>  
    <span class="kd">function</span> <span class="nx">mapStimulus</span> <span class="p">(</span><span class="nx">signal</span><span class="p">){...}</span>  
  
    <span class="k">this</span><span class="p">.</span><span class="nx">on</span><span class="p">(</span><span class="dl">'</span><span class="s1">stimulus</span><span class="dl">'</span><span class="p">,</span> <span class="p">(</span><span class="nx">signal</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="p">{</span>  
      <span class="kd">var</span> <span class="nx">sound</span> <span class="o">=</span> <span class="nx">mapStimulus</span><span class="p">(</span><span class="nx">signal</span><span class="p">);</span>  
      <span class="k">this</span><span class="p">.</span><span class="nx">emit</span><span class="p">(</span><span class="dl">'</span><span class="s1">sound</span><span class="dl">'</span><span class="p">,</span> <span class="nx">sound</span><span class="p">);</span>  
    <span class="p">};</span>  
  <span class="p">}</span>  
<span class="p">}</span>
</code></pre></div></div>

<p>We have effectively set up a chain of causality, which we make explicit by building a pipeline:</p>

<div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nx">tree</span><span class="p">.</span><span class="nx">pipe</span><span class="p">(</span><span class="nx">air</span><span class="p">).</span><span class="nx">pipe</span><span class="p">(</span><span class="nx">ear</span><span class="p">).</span><span class="nx">pipe</span><span class="p">(</span><span class="nx">brain</span><span class="p">);</span>
</code></pre></div></div>

<p>Now, when the tree falls it makes an impression on a mind:</p>

<div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nx">brain</span><span class="p">.</span><span class="nx">on</span><span class="p">(</span><span class="dl">'</span><span class="s1">sound</span><span class="dl">'</span><span class="p">,</span> <span class="p">(</span><span class="nx">sound</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="p">{</span>  
  <span class="c1">// We exit the system. You have been heard!  </span>
  <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">sound</span><span class="p">);</span>   
<span class="p">});</span>
<span class="nx">tree</span><span class="p">.</span><span class="nx">emit</span><span class="p">(</span><span class="dl">'</span><span class="s1">fall</span><span class="dl">'</span><span class="p">,</span> <span class="nx">fallData</span><span class="p">);</span>
</code></pre></div></div>

<p>Berkeley called this concept <em>Subjective Idealism</em>. <em>Idealism</em> because it asserts only thoughts or ideas exist, and <em>subjective</em> because reality is dependent on the subjects that perceive it. In my opinion, Subjective Idealism is the philosophy underpinning reactive programming. Berkeley writes,</p>

<blockquote>
  <p>It is indeed an opinion strangely prevailing amongst men, that houses, mountains, rivers, and in a word all sensible objects have an existence natural or real, distinct from their being perceived by the understanding. ‚Ä¶For what are the fore-mentioned objects but the things we perceive by sense‚Ä¶and is it not plainly repugnant that any one of these or any combination of them should exist unperceived?</p>
</blockquote>

<p>I love this quote for its self-assured audacity. Berkeley is essentially calling us crazy for thinking that houses, mountains and rivers exist. In our example, trees, air, ears and brains are false idols; the only reality is <code class="language-plaintext highlighter-rouge">mapFall</code>, <code class="language-plaintext highlighter-rouge">mapFrequency</code> and <code class="language-plaintext highlighter-rouge">mapStimulus</code>. Reality is then never consumed, as it is with objects when they retain state. Reality is merely transformed.</p>

<h3 id="subjective-idealism-in-practice"><em>Subjective Idealism</em> in Practice</h3>

<p>In OOP we create objects that encapsulate some kind of behavior. We then construct programs which are networked relationships of these objects. Our program is structurally a <em>graph</em>.</p>

<p>In FRP we create pipelines of functions that encapsulate causal relationships. Pipelines are then merged and branched to give the graph-like structure of an object-oriented program. However, there is an important limitation on the types of functions. Only <a href="https://en.wikipedia.org/wiki/Pure_function">pure functions</a> are allowed. That is, functions that cannot effect anything outside themselves. In our example, the <code class="language-plaintext highlighter-rouge">Ear</code> cannot change how the <code class="language-plaintext highlighter-rouge">Air</code> vibrated. This constraint ensures that our pipelines have a well-defined direction from cause to effect. In terms of structure, this means our program is a <a href="https://en.wikipedia.org/wiki/Directed_acyclic_graph">directed acyclic graph</a> (DAG).</p>

<p>To reason about software, we must think of it as a sequence of causal relationships. We must be able to <em>order</em> the program. Mathematically, a graph can be <a href="https://en.wikipedia.org/wiki/Topological_sorting">ordered</a> if and only if it is a DAG. This is true no matter how you write your program. Whether you choose OOP, FRP or XYZ. What‚Äôs special about FRP, though, is that ordering is enforced by the pattern.</p>

<p>In OOP, ordering is left unspecified. Objects can call methods on other objects. Objects can change the state of other objects. Everything has read and write privileges by default. Specifying an order is done manually by the developer. It is up to them to relate the sequential ordering of lines in a program to an ordering of the objects‚Äô causal relationships.</p>

<p>Unfortunately, this is all too easy to mess up. Notice that in OOP, when two objects write to the same shared state, you have a race condition. In FRP, when two functions try to affect one another you have an infinite loop. This is but one example of a theoretical pattern enforcing a practical result.</p>

<p>The bottom line is that it is not enough to encapsulate state. A well-written program will also encapsulate dependency.</p>

<h3 id="tradeoffs">Tradeoffs</h3>

<blockquote>
  <p>‚ÄúProgrammers know the benefits of everything and the tradeoffs of nothing.‚Äù
<em>‚Äî Rich Hickey</em></p>
</blockquote>

<p>You‚Äôd think after all this FRP praising and OOP bashing, I‚Äôd be firmly in the FRP camp. You‚Äôd be wrong! FRP is a programming pattern, and patterns serve to constrain solutions. If the ideal solution doesn‚Äôt satisfy the constraints, you‚Äôll be wasting energy fighting against the pattern.</p>

<p>To be concrete, there are a few simple annoyances of FRP. Take immutability ‚Äî you are always creating more memory. You can never, say, sort a list in place. You will always be creating a new list. In theory, immutability is a good pattern to observe. In practice, you may be memory constrained, and it may be a good idea to swim against the FRP current.</p>

<p>But this is not <em>the</em> glaring problem. The glaring problem is that FRP becomes an anti-pattern when you don‚Äôt know when two parts of a codebase will interact. Take, for example, a first person shooter game. Somewhere is a <code class="language-plaintext highlighter-rouge">bullet</code> object, and somewhere else is a <code class="language-plaintext highlighter-rouge">player</code> object. A bullet may hit a player, but it‚Äôs unclear when this will happen. These objects need to retain state (velocity of the bullet, health of the player, etc.) so it is available at the moment they interact. Perhaps in the abstract the entire game can be thought of as one causal pipeline, but that sounds more daunting to me than thinking in terms of decoupled objects and state.</p>

<p>To put on my philosophical hat once more, physics may decree that reality is one causal pipeline whose time evolution is governed by deterministic physical laws, and whose initial conditions (or probabilities) are provided by the big bang. But this is hardly how humans reason about cause and effect. We naturally slice up reality into higher-level objects and reason about their inter-relations. It can be simpler that way, even though it‚Äôs error prone!</p>

<p>I feel this is why FRP hasn‚Äôt been been wholly embraced by the programming community, even after seeing its many advantages. The best we should hope for when writing programs is to use FRP principles in places where its patterns fit the solution, and let them inspire OOP patterns where its patterns do not. To me this is a distinction between solutions that can be thought of as pipelines, and solutions that shouldn‚Äôt be.</p>

<h3 id="conclusion">Conclusion</h3>

<p>In philosophy the objective is not to solve our deepest problems, but to have a shared language and historical precedent to debate them. So when a new problem emerges, we don‚Äôt have to start over. Similarly for programming patterns. They are not used to decide right and wrong, as if these concepts have universal appeal. They are used to classify problems and their approaches.</p>

<p>We should also look to other disciplines, much older than computer science, to see whether their shared language and historical precedent can inspire our own. Then we may see that the question, ‚Äú<em>did the tree fall?</em>‚Äù is not answered with a <em>yes</em> or a <em>no</em>. That instead it questions a perspective. One that can frame our philosophy of epistemology or our architecture of programs. And one to which the answer lies between a state of mind, and a flow of thought!</p>

:ET